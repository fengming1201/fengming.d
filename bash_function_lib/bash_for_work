#***************************************#
#author:fengming
#date:Tue 10 Jan 2023 04:56:27 PM CST
#***************************************#
HELP_FUNC=fm-help_example
function fm-add_fjk_device_qr_code
{
	local flag=NO
	local default_passwd=admin
	local id_head="ID:"
	local user=
	local passwd_head="password:"
	local passwd=

	if [ $# -eq 1  ]
	then 
		tmp=$(echo $1 | grep "^1jfieg" )
		echo $tmp
		if [  x${tmp} = x  ]
		then
			${HELP_FUNC}  add_device_qr_code
			return 1
		else
			echo "tmp=$tmp"
			user=$1
			passwd=${default_passwd}
			flag=OK
		fi
	elif [ $# -eq 2  ]
	then
		tmp=$(echo $1 | grep "^1jfieg" )
		if [ x$tmp = x  ]
		then
			tmp=$(echo $2 | grep "^1jfieg" )
			if [ x$tmp = x  ]
			then
				${HELP_FUNC}  add_device_qr_code
				return 1
			else
				user=$2
				passwd=$1
				flag=OK
			fi
		else
			user=$1
			passwd=$2
			flag=OK
		fi

	else
		${HELP_FUNC}  add_device_qr_code
		return 1
	fi

	if [ -z $(which qrencode) ]
	then
		echo "please install qrencode first"
		echo "apt install qrencode"
		return 1
	fi		
	if [ $flag == "OK"  ]
	then
		qrencode -o  - -t UTF8 ${id_head}${user}${passwd_head}${passwd}
		echo "ID=${user}"
		echo "pass=${passwd}"
	fi
	return 0
}

function fm-wifi_qr_code
{
	local app=qrencode
	local default_opt="-o  - -t UTF8 -m 2"
	local mode="nomal"
	local ssid="none"
	local passwd=""

	#check app
	which ${app} > /dev/null
	if [ $? -ne 0 ];then echo "${app} not exist";echo "please install it first";echo "apt install ${app}";return 1;fi

	#check parameter
	if [ $# -lt 1 ] || [ $# -gt 3 ]
	then
        echo "DESCRIPTION:在终端生成二维码"
        echo "SYNOPSIS:"
        echo "         ${FUNCNAME}  [fjk]  ssid  [pass]"
		return 2
	fi
	#process param
	if [ $# -eq 1 ]
	then
		ssid=$1
	elif [ $# -eq 2 ]
	then
		if [ "x$1" = "xfjk" ]
		then
			mode=$1
			ssid=$2
			passwd=""
		else
			ssid=$1
			passwd=$2
		fi
	elif [ $# -eq 3 ]
	then
		if [ "x$1" = "xfjk" ]
		then
			mode=$1
			ssid=$2
			passwd=$3
		fi
	else
		echo "unknow format"
		return 3
	fi
	#merge qrcode format sting
	local qrcode_string="none"
	if [ "x${mode}" = "xfjk" ]
	then
		if [ "x${passwd}" = "x" ]
		then
			#fujikam open mode when password is empty
			qrcode_string="{\"s\":\"${ssid}\",\"p\":\"\",\"l\":\"zh\"}"
		else	
			qrcode_string="{\"s\":\"${ssid}\",\"p\":\"${passwd}\",\"l\":\"zh\"}"
		fi
	else
		if [ "x${passwd}" = "x" ]
		then
			#nomal open ode  when password is empty
			qrcode_string="WIFI:T:nopass;S:${ssid};P:;;"
		else
			qrcode_string="WIFI:T:WPA;S:${ssid};P:${passwd};;"
		fi
	fi
	echo "==${qrcode_string}"
	#generate qr code
	qrencode ${default_opt} ${qrcode_string}
	if [ ! $? -eq 0 ];then echo "exec qrencode wrong.";return 4;fi
	echo "mode:${mode} ssid:${ssid} pass:${passwd}"
	return 0
}

function fm-convert_url_to_qrcode
{
	local app=qrencode
	local default_opt="-o  - -t UTF8 -m 2"

	if [ $# -lt 1 ]
	then
		echo "ERROR:para wrong!!"
		echo "$FUNCNAME  URL"
		return 1
	fi
	#check app
	which ${app} > /dev/null
	if [ $? -ne 0 ];then echo "${app} not exist";echo "please install it first";echo "apt install ${app}";return 2;fi
	
	local qrcode_string=$*
	echo "URL:${qrcode_string}"
	qrencode ${default_opt} ${qrcode_string}
	
	return 0
}

function fjk_sign_tool
{
	local tool_path=${HOME}/XBox/XBox
	local app=bin/node
	local arg=generate_sign.js

	if [ $# -ne 1 ];then echo "parameter wrong!";echo "$FUNCNAME file";return 1;fi
	local file="$1"

	if [ ! -f "${file}" ];then echo "file:"${file}" not found";return 2;fi
	if [ ! -x ${tool_path}/${app} ];then echo "${tool_path}/${app} not exec permission";return 3;fi
	
	echo "${tool_path}/${app} ${tool_path}/${arg} ${file}"
	${tool_path}/${app} ${tool_path}/${arg} "${file}"

	if [ -e "pack.sig.${file}" ]
	then
		echo "generate sign success"
		echo "--->${file}"
		echo "--->pack.sig.${file}"
		return 0
	else
		echo "generate sign fail"
		return 4
	fi
}
function fm-fjk_sign_tool
{
	#check arg
	if [ $# -lt 1 ]
	then
		echo "parameter wrong!!"
		echo "$FUNCNAME filename / dirname"
		return 1
	fi
	
	local arg_list=$@
	for file in "${arg_list}"
	do
		if [ -f ${file} ]
		then
			fjk_sign_tool "${file}"
		elif [ -d ${file} ]
		then
			for filelist in $(find ${file} -type f -printf "%P\n")
			do
				fjk_sign_tool "${filelist}"
			done
		else
			echo "Unkown file type"
		fi
	done
	
	echo "done ......."
	return 0
}

function fm-svn_revert_all
{

	if ! which svn > /dev/null
	then
		return 1
	fi
	# svn revert --recursive .
	local change_file_list=$(svn st | grep ^[MCAD\!] | awk '{print $2}' | tac)
	local no_record_file_list=$(svn st | grep ^? | awk '{print $2}')

	for file in $change_file_list
	do 
		svn revert $file
	done

	for file in $no_record_file_list
	do
		if [ -d $file  ]
		then
			rm -rv $file
		else
			rm -v $file
		fi
	done

	echo "svn revert all files done"

	return 0
}

function fm-svngrep
{
	local app=grep
	local default_opt='--exclude=*.map  --exclude=*.o  --exclude=*.a  --exclude=*.bin  --exclude=*.bak  --exclude=*.out'
	which ${app} > /dev/null
	if [ $? -ne 0 ];then echo ¨ERROR:${FUNCNAME},${app} not exist!¨;return 1;fi;

	$app ${default_opt} $*
	return 0
}

function fm-svnls
{
	local app=svn
	local default_opt='st | grep -v ^?'
	which ${app} > /dev/null
	if [ $? -ne 0 ];then echo ¨ERROR:${FUNCNAME},${app} not exist!¨;return 1;fi;

	$app ${default_opt} $*
	return 0
}

function fm-svnst
{
	local app=svn
	local default_opt="st | grep -v ^?"
	which ${app} > /dev/null
	if [ $? -ne 0 ];then echo ¨ERROR:${FUNCNAME},${app} not exist!¨;return 1;fi;

	$app ${default_opt} $*
	return 0
}
function fm-gitcmd_help
{
	local cmd_help_path=${fengming_documents_dir}/sub_doc_git/git_cmd_help
	if [ $# -lt 1 ];then tree -L 1 ${cmd_help_path};return 0;fi
	if [ $# -gt 1 ] || [ $1 = "-h" ] || [ $1 = "--help" ]
	then
		echo "parameter wrong!"
		echo "$FUNCNAME cmd"
		echo "e.g.:$FUNCNAME  log"
		return 1
	fi
	if [ -f ${cmd_help_path}/${1} ]
	then
			echo "start >>>"
			cat ${cmd_help_path}/${1}
			echo "end <<<"
			echo "file:${cmd_help_path}/${1}"
			return 0;
	fi
	local cmd_file=$(find ${cmd_help_path} -type f -iname "git_*${1}*" -o -type l -iname "git_*${1}*")
	if [ "x${cmd_file}" != x ]
	then
		for file_each in ${cmd_file}
		do
			echo "start >>>"
			cat ${file_each}
			echo "end <<<"
			echo "file:${file_each}"
		done
	fi
	return 0
}
function fm-gitst
{
	if [ $1 = "-h" ] || [ $1 = "--help " ]
	then
		echo "no args"
		return 1
	fi
	git status > /dev/null  2>&1
	if [ $? -ne 0 ]
	then
		sudo git status
	else
		git status
	fi
	return 0
}
function fm-gitls
{
	if [ "$1" = "-h" ] || [ "$1" = "--help" ]
	then
		echo "no args"
		return 1
	fi
	git status > /dev/null 2>&1
	if [ $? -ne 0 ]
	then
		sudo git status | grep -E 'new file:|modified:|deleted:|renamed:|copied:'
	else
		git status | grep -E 'new file:|modified:|deleted:|renamed:|copied:'
	fi
	return 0
}
function fm-gitlog
{
	local tmp_file=$(mktemp)
	local ret=128
	if [ "$1" = "-h" ] || [ "$1" = "--help" ]
	then
		echo "no args"
		return 1
	fi

	git status > ${tmp_file}  2>&1
	ret=$?
	if [ "x$(grep "not a git repository" ${tmp_file})" != x ] && [ ${ret} -ne 0 ]
	then 
		echo "fatal: not a git repository"
		rm -f ${tmp_file}
		return 1
	fi
	rm -f ${tmp_file}

	if [ $ret -ne 0 ]
	then
		echo "git log --name-status"
		sudo git log --name-status
	else
		echo "git log --name-status"
		git log --name-status
	fi
	
	return 0
}
function fm-gitshow
{
	local tmp_file=$(mktemp)
	local ret=128
	if [ "$1" = "-h" ] || [ "$1" = "--help" ]
	then
		echo "no args"
		return 1
	fi

	git status > ${tmp_file}  2>&1
	ret=$?
	if [ "x$(grep "not a git repository" ${tmp_file})" != x ] && [ ${ret} -ne 0 ]
	then 
		echo "fatal: not a git repository"
		rm -f ${tmp_file}
		return 1
	fi
	rm -f ${tmp_file}
	if [ $ret -ne 0 ]
	then
		echo "git show"
		sudo git show
	else
		echo "git show"
		git show
	fi
	return 0
}
function fm-gitcat_file_by_commit_id
{
	if [ $# -lt 2 ] || [ "$1" = "-h" ] || [ "$1" = "--help" ]
	then
		echo ""
		echo "$FUNCNAME  commit_id  file or filelist"
		echo "git commit ID,you can :[git log --name-status]"
		echo "e.g.:$FUNCNAME  fef3d5a1053480cb9ddccd05fbdc1426b57a1086 main.c"
		echo "e.g.:$FUNCNAME  fef3d5a105 main.c"
		echo "NOTE:pay attention to the file path!!"
		return 0
	fi
	
	local commit_id=$1
	shift 1
	local file_list=$@
	git status > /dev/null 2>&1
	if [ $? -ne 0 ]
	then
		echo "git show ${commit_id}:${file_list}"
		sudo git show ${commit_id}:${file_list}
	else
		echo "git show ${commit_id}:${file_list}"
		git show ${commit_id}:${file_list}
	fi
	return 0
}
function fm-gitlog_detail_by_commit_id
{
	if [ $# -lt 1 ] || [ "$1" = "-h" ] || [ "$1" = "--help" ]
	then
		echo ""
		echo "(1)$FUNCNAME  commit_id"
		echo "(2)$FUNCNAME  commit_id  file or filelist"
		echo "git commit ID,you can :[git log --name-status]"
		echo "e.g.:$FUNCNAME  fef3d5a1053480cb9ddccd05fbdc1426b57a1086 main.c"
		echo "e.g.:$FUNCNAME  fef3d5a105 main.c"
		echo "NOTE:pay attention to the file path!!"
		return 0
	fi
	git status > /dev/null 2>&1
	local ret=$?
	local commit_id=$1
	if [ $# -gt 1 ]
	then
		shift 1
		local file_list=$@
		if [ $ret -ne 0 ]
		then
			echo "git show ${commit_id} -- ${file_list}"
			sudo git show ${commit_id} -- ${file_list}
		else
			echo "git show ${commit_id} -- ${file_list}"
			git show ${commit_id} -- ${file_list}
		fi
	else
		if [ $ret -ne 0 ]
		then
			echo "git show ${commit_id}"
			sudo git show ${commit_id}
		else
			echo "git show ${commit_id}"
			git show ${commit_id}
		fi
	fi
	return 0
}
function fm-gitdiff_work-cache
{
	local tmp_file=$(mktemp)
	local ret=128
	if [ $1 -lt 1 ] || [ "$1" = "-h" ] || [ "$1" = "--help" ]
	then
		echo " "
		echo "$FUNCNAME  file or file list"
		return 1
	fi

	git status > ${tmp_file}  2>&1
	ret=$?
	if [ "x$(grep "not a git repository" ${tmp_file})" != x ] && [ ${ret} -ne 0 ]
	then 
		echo "fatal: not a git repository"
		rm -f ${tmp_file}
		return 1
	fi
	rm -f ${tmp_file}
	local file_list
	for file in "$@"
    do
        if [ ! -f ${file} ]; then
            echo "WARNING:<${file}> not found,ignore it"
        else
            file_list+=("${file}")
        fi
    done
	
	if [ $ret -ne 0 ]
	then
		echo "git diff ${file_list}"
		sudo git diff ${file_list}
	else
		echo "git diff ${file_list}"
		git diff ${file_list}
	fi
	return 0
}
function fm-gitdiff_work-repository
{
	local tmp_file=$(mktemp)
	local ret=128

	if [ $1 -lt 1 ] || [ "$1" = "-h" ] || [ "$1" = "--help" ]
	then
		echo " "
		echo "$FUNCNAME  file or file list"
		return 1
	fi

	git status > ${tmp_file}  2>&1
	ret=$?
	if [ "x$(grep "not a git repository" ${tmp_file})" != x ] && [ ${ret} -ne 0 ]
	then 
		echo "fatal: not a git repository"
		rm -f ${tmp_file}
		return 1
	fi
	rm -f ${tmp_file}

	local file_list
	for file in "$@"
    do
        if [ ! -f ${file} ]; then
            echo "WARNING:<${file}> not found,ignore it"
        else
            file_list+=("${file}")
        fi
    done
	
	if [ $ret -ne 0 ]
	then
		echo "git diff --cached ${file_list}"
		sudo git diff --cached ${file_list}
	else
		echo "git diff --cached ${file_list}"
		git diff --cached ${file_list}
	fi
	return 0
}

function fm-gitinfo
{
	local tmp_file=$(mktemp)
	local ret=128
	if [ "$1" = "-h" ] || [ "$1" = "--help" ]
	then
		echo "no args"
		return 1
	fi
	git status > ${tmp_file}  2>&1
	ret=$?
	if [ "x$(grep "not a git repository" ${tmp_file})" != x ] && [ ${ret} -ne 0 ]
	then 
		echo "fatal: not a git repository"
		rm -f ${tmp_file}
		return 1
	fi
	rm -f ${tmp_file}
	if [ ${ret} -ne 0 ]
	then
		echo "{"
		sudo git remote -v
		echo "},"
		echo "{"
		sudo git branch
		echo "}"
	else
		echo "{"
		git remote -v
		echo "},"
		echo "{"
		git branch
		echo "}"
	fi
	return 0
}
