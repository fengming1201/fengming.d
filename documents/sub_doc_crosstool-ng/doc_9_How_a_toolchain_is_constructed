如何构建工具链
这是与弗朗切斯科讨论的结果 图尔科。

弗朗切斯科有一个很好的教程 初学者[死链接，Wayback Machine没有存档版本]， 以及构建工具链的示例分步过程 来自 Debian 
主机x86_64 的 ARM 目标。

谢谢弗朗切斯科发起这个！

我想要一个交叉编译器！你说的这个工具链是什么？
交叉编译器实际上是不同工具的集合，设置为 紧密协作。工具的排列方式如下 链式的，在一种级联中，其中一个的输出成为 
输入到另一个，最终生成实际的二进制代码 在计算机上运行。因此，我们将这种安排称为“工具链”。当一个 工具链旨在为与 
它运行的机器，这称为跨工具链。

那么，工具链中的这些组件是什么？
在工具链中发挥作用的组件首先是最重要的 编译器本身。编译器将源代码（在 C、C++、 无论如何）进入汇编代码。
选择的编译器是 GNU 编译器 集合，众所周知。gcc

汇编代码由汇编程序解释以生成对象 法典。这是由二进制实用程序完成的，例如GNU binutils。

生成不同的目标代码文件后，它们就可以 聚合在一起以形成最终的可执行二进制文件。这是 称为链接，通过使用链接器实现。GNU binutils还带有一个链接器。

到目前为止，我们得到了一个完整的工具链，能够转换源代码 代码转换为实际的可执行代码。取决于操作系统，或 缺少它，在目标上运行，
我们还需要 C 库。这 C 库提供了一个执行基本操作的标准抽象层 任务（例如分配内存、在终端上打印输出、 管理文件访问...有许多 C 库，
每个库都针对 不同的系统。对于 Linux 桌面，有甚至 ，对于嵌入式 Linux，您可以选择 或 ，而对于没有操作系统的系统，您可以使用 、 ，
甚至根本不使用。还有其他一些C 库，但它们没有被广泛使用，和/或针对非常 特定需求（例如，是 C 库的非常小的子集 
旨在构建受约束的初始虚拟硬盘）。glibceglibcuClibceglibcuClibcnewlibdietlibcklibc

在 Linux 下，C 库需要知道内核的 API 才能决定 存在哪些功能，如果需要，要包含哪些仿真 缺少功能。该 API 由内核标头提供。
注意：这 是特定于 Linux 的（可能还有其他极少数），C 库在 其他操作系统不需要内核标头。

现在，所有这些组件是如何链接在一起的？
到目前为止，所有主要组件都已涵盖，但还有一个 它们需要构建的特定顺序。在这里我们看看依赖关系是什么 是，
从我们最终想要使用的编译器开始。我们称之为 编译器 最终编译器。

最终的编译器需要 C 库，知道如何使用它，但是：

构建 C 库需要编译器

A 需要 B，而 B 需要 A。这是典型的先有鸡还是先有蛋的问题...这 通过构建一个不需要 C 的精简编译器来解决 库，但能够构建它。
我们称之为引导程序，初始， 或核心编译器。所以这是新的依赖列表：

最终的编译器需要C库，知道如何使用它，

构建 C 库需要一个核心编译器，但：

核心编译器需要 C 库标头和启动文件，以 知道如何使用 C 库

B需要C，C又需要B.鸡蛋。为了解决这个问题，我们 将需要构建一个仅安装其标头的 C 库和 启动文件。
启动文件（也称为“C 运行时”或 CRT）是 GCC 需要能够打开本地线程的极少数文件 NPTL 系统上的存储 （TLS）。所以现在我们有：

最终的编译器需要C库，知道如何使用它，

构建 C 库需要核心编译器

核心编译器需要 C 库标头和启动文件，以 知道如何使用 C 库，但是：

构建启动文件需要编译器

吉兹语。。。C 需要 D，而 D 又需要 C。所以我们需要建立一个 更简单的编译器，不需要标头，需要启动 文件。
该编译器也是引导程序、初始编译器或核心编译器。在 为了区分两个核心编译器，我们称之为一个，前一个。依赖关系列表 成为：core pass 1core pass 2

最终的编译器需要C库，知道如何使用它，

构建 C 库需要编译器

核心通行证 2 编译器需要 C 库标头并启动 文件，以了解如何使用 C 库

构建启动文件需要编译器

我们需要一个核心通行证 1 编译器

正如我们之前所说，C 库也需要内核标头。 对内核标头没有要求，所以故事结束了 箱：

最终的编译器需要C库，知道如何使用它，

构建 C 库需要核心编译器

核心通行证 2 编译器需要 C 库标头并启动 文件，以了解如何使用 C 库

构建启动文件需要编译器和内核头文件

我们需要一个核心通行证 1 编译器

我们需要添加一些新要求。我们编译代码的那一刻 目标，我们需要汇编器和链接器。这样的代码是， 
课程，从 C 库构建，因此我们需要构建二进制文件 在 C 库启动文件之前，以及完整的 C 库本身。 此外，
gcc 中的一些代码也会转向在目标上运行。幸 对二进制没有要求。因此，我们的依赖链为 遵循：

最终的编译器需要 C 库，知道如何使用它，并且 比努尔斯

构建 C 库需要一个核心通道 2 编译器和 比努尔斯

核心通行证 2 编译器需要 C 库标头并启动 文件，以了解如何使用 C 库和二进制文件

构建启动文件需要一个编译器、内核头文件和 比努尔斯

核心通行证 1 编译器需要 binutils

按以下顺序生成组件：

比努尔斯

核心通道 1 编译器

内核头文件

C 库头文件和启动文件

核心通道 2 编译器

完整的 C 库

最终编译器

是的！:-)但是我们完成了吗？

事实上，不，仍然缺少依赖项。就工具而言 他们自己参与其中，我们不需要其他任何东西。

但是 gcc 有一些先决条件。它依赖于一些外部库 执行一些重要的任务（例如处理 常量...有几个选项可以构建这些库。第一 
人们可能会认为依靠Linux发行版来提供这些 图书馆。唉，直到非常非常，它们才被广泛使用 最近。因此，如果发行版不是太新，
我们很可能会 必须构建这些库（我们在下面做）。受影响的 库是：

GNU 多精度算术库，GMP;

用于多精度浮点计算的 C 库 四舍五入正确，强积金;

用于复数算术的 C 库，MPC。

这些库的依赖项包括：

MPC 要求 GMP 和 MPFR

MPFR要求GMP

GMP没有先决条件

因此，构建顺序变为：

药品监督管理总局

强积金

MPC

比努尔斯

核心通道 1 编译器

内核头文件

C 库头文件和启动文件

核心通道 2 编译器

完整的 C 库

最终编译器

是的！还是更多？

现在，这足以构建一个功能工具链。所以如果你有 现在够了，你可以停在这里。或者，如果您好奇，可以 继续阅读。

GCC 还可以使用其他一些外部库。这些 此外，可选库用于启用 gcc，例如环路优化（GRAPHITE）和链路时间优化 （LTO）。如果要使用这些库，则需要三个额外的库：

要启用 GRAPHITE，根据 GCC 版本，它可能需要一个或多个 以下内容：

帕尔马多面体图书馆，PPL;
整数集库，ISL;
Chunky Loop Generator，使用 PPL 后端 CLooG/PPL;
Chunky Loop Generator，使用 ISL 后端 CLooG。
要启用 LTO： - ELF 对象文件访问库，libelf

这些库的依赖项包括：

PPL要求GMP;

CLooG/PPL需要GMP和PPL或ISL之一;

ISL 没有先决条件;

诽谤没有先决条件。

该列表现在如下所示：

药品监督管理总局

强积金

MPC

PPL（如果需要）

ISL（如果需要）

CLooG （如果需要）

诽谤（如果需要）

比努尔斯

核心通道 1 编译器

内核头文件

C 库头文件和启动文件

核心通道 2 编译器

完整的 C 库

最终编译器

此列表现已完成！呜！还是吗？

但是为什么crosstool-NG有更多的步骤呢？
已经十三个步骤是必要的步骤，从理论上讲 观点。然而，实际上，存在细微的差异;那里 是交叉工具-NG 中额外步骤的三个不同原因。

首先，GNU binutils不支持某些类型的输出。它不是 可以使用二进制文件生成平面二进制文件，因此我们必须使用 添加此支持的另一个组件：。 
也需要压缩库 - 我们可能无法使用 主机的 zlib 如果我们正在构建加拿大或跨原生工具链。elf2fltelf2fltzlib

其次，工具链的本地化需要额外的库 在某些主机操作系统上：和 。gettextlibiconv

第三，crosstool-NG还可以构建一些额外的调试实用程序来 在目标上运行。这就是我们构建的地方，例如， 
和本机（最后两个在目标上运行， 第一个与工具链在同一台机器上运行）。其他 （、、DUMA 和 ）绝对与 工具链，但很好的东西，
可以在以下情况下提供很大帮助 开发，所以被包括在内作为好东西（而且它们很容易 构建，所以没关系;更复杂的东西不值得努力包含 
在交叉工具-NG）。cross-gdbgdbservergdbstraceltracedmalloc