Dockerfile 中每一条指令都创建镜像的一层。例如：
FROM ubuntu:18.04 
MAINTAINER Docker Newbee <newbee@docker.com> 
RUN apt-get -qq update 
RUN apt-get -qqy install ruby ruby-dev 
RUN gem install sinatra 

Dockerfile 基本的语法是 
使用 # 来注释 
FROM 指令告诉 Docker 使用哪个镜像作为基础 
接着是维护者的信息 
RUN 开头的指令会在创建中运行，比如安装一个软件包，在这里使用 apt-get 来安装了一些软件
编写完成 Dockerfile 后可以使用 docker build 来生成镜像。
例如：
# docker build -t "mytest3:1.1.0" .

文件名必须是Dockerfile,
".”	是	Dockerfile	所在的路径（当前目录），也可以
替换为一个具体的	Dockerfile	的路径。

## 指令详解

### FROM
**语法**：FROM <镜像名称>[:<标签>] 或 FROM <镜像名称>@<镜像摘要>
**说明**：指定基础镜像，是Dockerfile的第一条指令（除了注释外）。每个有效的Dockerfile必须以FROM指令开始。
**示例**：
FROM ubuntu:20.04  # 使用Ubuntu 20.04作为基础镜像
FROM alpine:latest  # 使用最新的Alpine镜像作为基础镜像

### LABEL
**语法**：LABEL <key>=<value> [<key>=<value>...]
**说明**：为镜像添加元数据信息，以键值对形式存储。可添加多个LABEL，便于组织和检索镜像。
**示例**：
LABEL maintainer="John Doe <john@example.com>"
LABEL version="1.0"
LABEL description="这是一个示例镜像"

### RUN
**语法**：
- RUN <command> （shell格式）
- RUN ["executable", "param1", "param2"] （exec格式）
**说明**：在镜像构建过程中执行命令，用于安装软件包、配置环境等。
**示例**：
# shell格式安装软件包
RUN apt-get update && apt-get install -y nginx

# exec格式创建目录
RUN ["mkdir", "-p", "/app/data"]

### CMD
**语法**：
- CMD <command> （shell格式）
- CMD ["executable", "param1", "param2"] （exec格式）
- CMD ["param1", "param2"] （为ENTRYPOINT提供默认参数）
**说明**：指定容器"启动时"默认执行的命令。可以被docker run命令行参数覆盖。
**注意**：Dockerfile中如果有多个CMD指令，只有最后一个生效。
**示例**：
# shell格式启动nginx
CMD nginx -g 'daemon off;'

# exec格式启动应用
CMD ["node", "app.js"]

### ENTRYPOINT
**语法**：
- ENTRYPOINT <command> （shell格式）
- ENTRYPOINT ["executable", "param1", "param2"] （exec格式）
**说明**：设置容器""启动时的主要命令。与CMD不同，不会被命令行参数覆盖，而是作为"固定"的入口点。
**注意**：Dockerfile中如果有多个ENTRYPOINT指令，只有最后一个生效。
**示例**：
# exec格式（推荐）
ENTRYPOINT ["nginx", "-g", "daemon off;"]

# 与CMD结合使用
ENTRYPOINT ["ping"]
CMD ["localhost"]  # 可在运行时覆盖：docker run image google.com

### EXPOSE
**语法**：EXPOSE <端口1> [<端口2>...]
**说明**：声明容器运行时监听的网络端口。这只是一个声明，实际发布需使用-p参数。
**示例**：
EXPOSE 80  # 声明监听80端口
EXPOSE 80 443  # 声明监听80和443端口

### ENV
**语法**：
- ENV <key> <value>
- ENV <key1>=<value1> <key2>=<value2>...
**说明**：设置环境变量，可在构建过程和容器运行时使用。
**示例**：
ENV NODE_VERSION 16
ENV PATH=/app/node_modules/.bin:$PATH

# 使用环境变量
RUN curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz"

### ADD
**语法**：
- ADD [--chown=<user>:<group>] <源路径>... <目标路径>
- ADD [--chown=<user>:<group>] ["<源路径>",... "<目标路径>"]
**说明**：将文件、目录或远程URL复制到镜像中。可以自动解压压缩文件。
**示例**：
ADD package.json /app/
ADD app.tar.gz /app/  # 自动解压
ADD https://example.com/config.json /app/

### COPY
**语法**：
- COPY [--chown=<user>:<group>] <源路径>... <目标路径>
- COPY [--chown=<user>:<group>] ["<源路径>",... "<目标路径>"]
**说明**：将文件或目录复制到镜像中。比ADD更推荐使用，因为功能更明确，不会自动解压或下载。
**示例**：
COPY index.html /usr/share/nginx/html/
COPY src/ /app/src/
COPY *.txt /app/docs/

### VOLUME
**语法**：
- VOLUME ["<路径1>", "<路径2>",...]
- VOLUME <路径>
**说明**：为容器创建挂载点或声明卷。用于持久化数据或在容器间共享数据。
**示例**：
VOLUME /data
VOLUME ["/data", "/logs"]

### WORKDIR
**语法**：WORKDIR <工作目录路径>
**说明**：设置后续指令的工作目录。如果目录不存在，会自动创建。
**示例**：
WORKDIR /app
WORKDIR /app/src

### USER
**语法**：USER <用户名>[:<用户组>]
**说明**：指定后续命令的用户上下文。用户和用户组必须提前已存在。
**示例**：
RUN useradd -m appuser
USER appuser

### ARG
**语法**：ARG <参数名>[=<默认值>]
**说明**：定义""构建"参数，可通过docker build --build-arg <参数名>=<值>覆盖。构建完成后这些变量不会保存在镜像中。
**示例**：
ARG NODE_VERSION=16
FROM node:${NODE_VERSION}

### ONBUILD
**语法**：ONBUILD <指令>
**说明**：当该镜像被用作另一个构建过程的基础时，添加触发器。用于创建可重用的基础镜像。
**示例**：
FROM node:16
WORKDIR /app
ONBUILD COPY package*.json ./
ONBUILD RUN npm install
ONBUILD COPY . .
ONBUILD RUN npm run build

### HEALTHCHECK
**语法**：
- HEALTHCHECK [选项] CMD <命令>
- HEALTHCHECK NONE  # 禁用任何健康检查
**选项**：
- --interval=<间隔>：健康检查间隔，默认30秒
- --timeout=<超时>：健康检查超时时间，默认30秒
- --start-period=<启动期>：容器启动宽限期，默认0秒
- --retries=<重试次数>：连续失败次数判定为不健康，默认3次
**说明**：定义周期性检查容器健康状态的命令。
**示例**：
HEALTHCHECK --interval=5m --timeout=3s CMD curl -f http://localhost/ || exit 1

### STOPSIGNAL
**语法**：STOPSIGNAL <信号>
**说明**：设置发送给容器以退出的系统调用信号。默认是SIGTERM。
**示例**：
STOPSIGNAL SIGINT  # 使用Ctrl+C信号
STOPSIGNAL 9  # 使用SIGKILL信号

### SHELL
**语法**：SHELL ["可执行文件", "参数1", "参数2",...]
**说明**：覆盖Docker中默认的shell，用于RUN、CMD和ENTRYPOINT指令。在Windows环境中特别有用。
**示例**：
SHELL ["/bin/bash", "-c"]  # 使用bash替代默认的sh

### FROM ... AS name (多阶段构建)
**语法**：FROM <镜像> AS <阶段名称>
**说明**：多阶段构建中的命名阶段，允许后续阶段引用该阶段构建的内容。用于优化镜像大小。
**示例**：
# 构建阶段
FROM node:14 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# 生产阶段
FROM nginx:alpine
COPY --from=builder /app/build /usr/share/nginx/html

### COPY --from=name|stage
**语法**：COPY --from=<阶段名称|镜像名称> <源路径>... <目标路径>
**说明**：从多阶段构建的指定阶段复制文件。
**示例**：
COPY --from=builder /app/dist /usr/share/nginx/html

### LABEL maintainer
**语法**：LABEL maintainer="<名称> <邮箱>"
**说明**：推荐用于替代MAINTAINER的维护者信息设置方式。
**示例**：
LABEL maintainer="John Doe <john.doe@example.com>"